ðŸ”¹ SOLID Principles (with Examples in Java)
1. S â†’ Single Responsibility Principle (SRP)
ðŸ“Œ A class should have only one reason to change.
âœ… Example (Bad):
class UserService {
    public void addUser(String user) {
        // logic to add user
    }

    public void generateReport() {
        // logic to generate report
    }
}


ðŸ‘‰ Here, UserService does two jobs (user management + reporting).

âœ… Example (Good):

class UserService {
    public void addUser(String user) {
        // logic to add user
    }
}

class ReportService {
    public void generateReport() {
        // logic to generate report
    }
}


ðŸ‘‰ Now each class has a single responsibility.

2. O â†’ Open/Closed Principle (OCP)

ðŸ“Œ Classes should be open for extension but closed for modification.

âœ… Example (Bad):

class Payment {
    public void pay(String type) {
        if (type.equals("CreditCard")) {
            // credit card logic
        } else if (type.equals("UPI")) {
            // UPI logic
        }
    }
}


ðŸ‘‰ Adding new payment types requires modifying this class.

âœ… Example (Good â€“ using Polymorphism):

interface Payment {
    void pay();
}

class CreditCardPayment implements Payment {
    public void pay() {
        System.out.println("Paid using Credit Card");
    }
}

class UpiPayment implements Payment {
    public void pay() {
        System.out.println("Paid using UPI");
    }
}


ðŸ‘‰ Now we can add new payment types without modifying existing code.

3. L â†’ Liskov Substitution Principle (LSP)

ðŸ“Œ Objects of a superclass should be replaceable with objects of a subclass without breaking the application.

âœ… Example (Bad):

class Bird {
    void fly() { }
}

class Penguin extends Bird {
    @Override
    void fly() {
        throw new UnsupportedOperationException("Penguins can't fly!");
    }
}


ðŸ‘‰ Violates LSP because Penguin cannot behave like a Bird.

âœ… Example (Good):

abstract class Bird { }

class FlyingBird extends Bird {
    void fly() { }
}

class Penguin extends Bird {
    void swim() { }
}


ðŸ‘‰ Now substitution works properly.

4. I â†’ Interface Segregation Principle (ISP)

ðŸ“Œ Clients should not be forced to depend on methods they do not use.

âœ… Example (Bad):

interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() { }
    public void eat() { // Robots donâ€™t eat!
        throw new UnsupportedOperationException();
    }
}


ðŸ‘‰ Violates ISP.

âœ… Example (Good):

interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Human implements Workable, Eatable {
    public void work() { }
    public void eat() { }
}

class Robot implements Workable {
    public void work() { }
}


ðŸ‘‰ Now clients depend only on what they need.

5. D â†’ Dependency Inversion Principle (DIP)

ðŸ“Œ High-level modules should not depend on low-level modules. Both should depend on abstractions.

âœ… Example (Bad):

class MySQLDatabase {
    public void connect() { }
}

class UserService {
    private MySQLDatabase db = new MySQLDatabase();
}


ðŸ‘‰ UserService is tightly coupled to MySQLDatabase.

âœ… Example (Good):

interface Database {
    void connect();
}

class MySQLDatabase implements Database {
    public void connect() { }
}

class OracleDatabase implements Database {
    public void connect() { }
}

class UserService {
    private Database db;
    public UserService(Database db) {
        this.db = db;
    }
}


ðŸ‘‰ Now we can switch databases easily (loose coupling).

ðŸ”¹ Quick One-Liner Summary for Interview

S â†’ One class = One responsibility.

O â†’ Extend, donâ€™t modify.

L â†’ Subclasses should be replaceable by parent classes.

I â†’ No unnecessary methods in interfaces.

D â†’ Depend on abstractions, not concrete implementations.